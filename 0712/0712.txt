private 네트워크 구축

geth - miner.start() -> POW 합의 알고리즘을 이용하여 블록생성

parity -> 자동으로 마이닝 동작 -> POA

일반적으로 4대 정도로 운용. (이더리움 기준)
패브릭은 노드의 수가 더 늘어난대

geth 같은경우는 리소스를 많이 잡아먹기때문에 노드가 자주 죽음
하루에도 여러번 확인해야함

shell 코드로 확인을 해서 죽었는지 살았는지 확인

scheduler - 노드가 죽었는지 자동으로 확인하는 기능
crontab 
윈도우 작업 스케줄러

git bash
vim genesis.json
bash는 모든걸 파일로 관리

ls
genesis.json

ubuntoo
usr = user directory
명령어들이 bin 안에 들어있고
log 파일같은게 /etc로 들어감

cd /etc
tmp = 임시폴더 temporary. log정보가 들어가기도 하낟

unix에서는 이런식으로 파일관리를 한대

cpu = 단일 프로세서(1core) - 병렬처리가 불가능 - 코어수가 적어서
1코어당 1개의 프로세서만 실행시킬 수 있대.
근데 코어 하나당 연산능력이 매우 좋대
내부에 저장공간이 적음 64mb, 128mb

memory
8gb, 16gb

저장소 512gb, 1tb
VScode: 300mb

연산능력, 저장소는 반비례

연산이 제일 많아지는 것중에 하나가 네트워큰데
네트워크 연산을 담당하는게 운영체제래
그래서 요청이 많아질수록 cpu 점유율이 올라간대
프로그램이 불안정하다는게 점유율이 노이즈튀는거 오르락 내리락이 심한게 
90프로라도 일정하게 90프로인건 괜찮대

cmd systeminfo

32bit(4byte), 64bit(8byte) 운영체제

자료구조 운영체제 공룡책

parity 도 POW로 만들수 있는데 POA

이 얘기 왜했는지 모르겠음

cURL
web browser에서 도메인을 입력하면 받아오는 역할?

redirection: 새로고침. 이동

git bash에서 curl 을 치면 에러가아니라 명령어로 입력하라고 나옴

curl 치고 주소 치면 된대
그 주소에 대한 결과물을 출력을 해준대
cls? clear - 깨끗 명령어

curl naver.com = 뭐 어쩌구 저쩌구
curl https://naver.com 뜬다

server에 html data를 요청해서 받은 결과를 보여준다
rendering이 안된상태?

에스로 릴라이트 된다?

html을 실행을 해가지고 그거를 렌더링이라고 어쩌구
명령어를 실행하는걸 지원하지 않음?

윈도우는 curl을 지원하지 않늗내

curl for windows 를 설치하면 cmd에서 실행가능

git bash
echo $PATH -> 쨕

각 3개의 노드가 있다고 가정

블록생성 주기가 0.1 sec.
블록 전파 지연시간이 1 sec 라고 하면
채 첫번째 블록을 수신하기 전에 10개나 생성을 해버리고
이 때 각 노드별로 달라져버린 벽을 생성하게 되고
uncle block 이라고 포크가 일어나고
다른 네트워크가 생겨버린다?

그래서 보통 블록생성주기를 5초로 설정을 한다

POW 같은 경우는 누구나 남쳐을 할 수 있는데
POA 는 
valiadators = 검증 증명
리스트에 있는 애들만 mining 채굴을 할수가 있다

보통 validator 를 생성을 해놓는데
4명 정도가 제일 좋대

실행할 때는 누가 검증을 할건 ㅑ어쩌구 젖쩌구
config.toml 에서 
[mining]
engine_signer = "0xae203a3d00e7c0ea613abfc9f284eaee7da74031"  # validator에 등록한 계정중 하나 넣기

여기에 넣어야 한대

리스트를 읽어오는데, database가 아니라
파일을 일일히 읽어와야 하고

그 파일에서 engine_signer 를 찾아야 하는데
컴터에서 제일 느린게 파이프라인을 형성하는 거고
특정파일을 읽기 위해서는 pipeline을 만들어야 하는데,
하드에서 이 파이프라인을 찾았다가 지우는게 하드에서 가장 많은 연산량을 차지
그리고 파이프라인을 만드는 작업은 처리속도가 굉장히 느리대

블록생성 속도를 5초라고 했는데
벨리데이터 리스트가 길어지면 길어질수록 추가로 지연시간이 붙는다
1000개를 등록하고 엔진 사이너에 어쩌구 저쩌구
했더니 50분걸렸대

등록할 때 이런걸 shell 코드를 쓴대

shell 코드에도 반복문이 존재한대

geth는 admin 어쩌구로 node peer를 어쩌구

parity는 자동으로 node 어쩌구 저쩌죽

.toml
설정파일 - rust 에서 사용하는 파일형식
parity는 rust로 만들어졌다

parity --config config.toml --geth

logrotate
스케쥴러처럼 로그를~
Worker: 프로그램을 실행하는 단위
와일드카드: *(all)

이 node에 geth로 접속

실행할때 &를 붙이면 특이하게 실행됨

git bash

ps 명령어 = 실행중인 프로세스 보여줌
ps -ef 전체 프로세스 보여줌
ps -df | grep parity parity만 보여줘

kill X 프로세스 남바
kill 12608 -> 12608 조욜
sudo su

taskkill /im git-bash.exe
taskkill /pid 12996 /f

authority round = 돌아가면서 검증을 하겠다

2개의 노드에서 rpc-port 같게해서 실행하면 안됨

이미 해당 포트가 할당됐거나 사용중이거나 해서 실행이 안되야 정상

3일동안 한것.

1. geth를 이용해서 POW 기반 private 네트워크 구축
2. parity를 이용해서 POA 기반 private 네트워크 구축

-> 블록체인 네트워크(인프라) 구축
-> 서버 구축 작업

레퍼런스가 없음. RPC 동일할때 실행됐던 현상

genesis 블록이 같을때라야 노드끼리 붙기 때문에
genesis.jason은 복사해서 이용

순서로 data를 조회하는게 아니라 key로 조회하기 때문에
key만 같으면 된다?

pk2에는 없는 account 에서 genesis를 복사해서 붙여넣었는데

3개요소
1. block
2. transaction
3. state

블록체인에서 가장 중요한건 스테이트
스테이트를 동일하게해서 하는거. 어떻게 동일하게 할것인가

노드별로 이노드 저노드 다 동일하게 저장을 하는데,

account를 생성하는데, 스테이트에 account를 집어넣지않음

account 생성의 의미는 말그대로 생성이아니라 소유권을 이전하는 것.

블록체인에서 전송과 조회를 할 때,
없는 계정을 조회나 전송을 해도 실패가 뜨지 않고 성공이 뜸

거래소에서 없는계정에다가 보내도 전송이 됨
그래서 계좌를 잘 확인하고 보내라는게 이 뜻.

블록체인에서는 '없는' 상태 라는건 없다. data는 다 존재하고
소유권만 주지 않고 다 저장은 되어 있다.

블록체인에서 0이란 값은 없는 것과 같은 상태
이 계좌에 대해서 증명을 해주는 것이 private key

계좌생성의 정확한 의미는 소유권을 준다는 의미?

invalid address? 는 없는거라는 증명하는건데
그것만 검사를 한대. 주소형태. 16진수 인지. 길이가 맞는지

생성이라는건 정확히 생성이 아니라
private key를 사용자에게 주는것.

pk1
pk2 를 생성을 했는데

pk1은 소유권을 가지고 있고
pk2는 소유권이 없는것. 하지만 두개다 저장은 되어있고
(사실 정확히 말하자면 저장이 다된건 아니래)
실행이 됐던것.

여러개의 노드에 data가 다 들어갈 수 있는데,
어떤 데이터를 업데이트를 할 것이냐 인데

바로바로 state에 저장하면 문제가 생기기 때문에

POW냐 POA냐 에 따라 다름

들어온 data로 바꿔주세요 하고 요청이 들어오면 : 이게 tx. tx가 발생이 된것
요청이 들어오면 누군가가 이걸 승인 해서 바꿔줘야 되는데
block에 들어갔다 하면 승인이 된것.

전파를했을때 block을 받게 되는데, 승인된 tx들이 있을 것이고
이 block에 있는 tx들을 확인을 해서 진행 하게 되고
이러면서 승인이 되면 state에 저장하게 됨

POW POA PDS DPOS 등 많은데

어떻게 집어넣을 것이냐 하는게 알고리즘이 다른것

노드별로 요청 전파 블록에 있는 tx를 하나씩 읽으면서
data가 들어갈 공간에 state 저장

geth에도 chain data에 저장이 되고
parity 같은 경우에 db에 저장이 된대

이러한 경위로 data의 위변조가 힘들다 - 수정 삭제가 안된다

맞는 말인데, block 이나 tx에는 해당이 되는 말이 맞음
state에는 수정이 됨. ether를 보내면 바로 수정이 됨

위변조가 되는게 51% 공격?

block 같은 경우에 #0 -  #1  -  #2 이렇게 있으면
각각                     #0hash #1hash 이렇게 가지고 있으면
                                        요 거를 바꾸려면 #2해쉬 전체를 바꿔야하고
연결되는 뒷 블럭들도 다 바꿔야 하기때문에 힘들다고 하는것.

3개체인 10개체인 이렇게 있으면 10개체인 (더 긴 체인) 을 메인체인으로 사용한다

geth 같은경우에 천개 2천개 생성이 되는게
genesis에서 difficulty를 낮춰서 그럼. 난이도를 조정을 하면서
블록생성 주기를 맞추는 것.
너무 느리면 난이도를 낮게. 너무 빠르면 난이도를 높게

난이도를 초기에 낮춰놨기 때문에, 올라갈 시간이 필요함
이렇게 하루종일 켜놓으면 8천개 정도가 생기는데,
10~20초 사이에 하나씩 생기도록 점점 난이도가 올라감
천천히 서서히 올라감
너무 높아도 조금씩 내려오고

어느순간 회귀되서 잔잔한 물결같은 그래프를 이루게 된다.
POW 같은경우는 8천개 정도에서 이게 조절이 디ㅗㄴ다

POA는 이걸 신경 안써도 된대

tx를 발생시키는건 이렇게  data를 바꿔주세요 하고 요청을 하는 것이고

그리고 ethereum과 state에 더 깊게 들어가자면

account 구조를 사용함
account 구조라는 건 다른말로 state의 구조

1. ether 보유량
2. smart contract의 경우 data. code.

이더리움의 경우 위 2가지를 어떻게 관리할 것인가 문제인데,

비트코인은 그냥 얼만큼 가지고 있습니다. 가 내용의 끝
ex> adress 보유량. 2가지가 끝

이더리움은 이에 더해

adress, 다량의 data. (위으 1,2)가 들어가게 됨

4가지가 들어간다.

value: ether 보유량
nonce: 이 주소가 몇번의 tx를 발생했는지 기록
code: solidity
dApp: 위 solidity에서 배포한 code가 여기 들어감

account 구조는
1. EOA: wallet 주소
2. CA: contract 주소

remix를 이용하고 뭐 하면 발생하는 주소가 CA

code가 있으면 CA, 없으면 EOA로 판단을 한다

비트코인은 이렇게 안돼있어요.

EOA랑 CA의 차이가있는데

EOA 코드x CA=코드o

private key: EOA=o, CA=x
누가했다는 그거를 private key로 서명을 해야하고 그 과정이 있어야 전송이 되는데

CA는 private key가 없고 스스로 contract를 발생시킬 수 없고 누가 도와줘야됨

따라서 tx 발생: EOA=가능, CA=불가

비트코인의 경우에는 특이하게 UTXO라는걸 사용
사용되지 않은 tx 라고 함. 현실세계에서 지갑과 완전 동일한 개념.

node가 있으면, account를 object 형태로
address, 보유량 식으로 저장이 되어 있는데,

3 node가 있을 때, node마다 account가 하나씩 있다.
예를 들어서 어느 꼐정이든 돈이 있으면 어디서든 다 조회가 되는데,

각 노드에 있는 계정을 부모계정이라고 함.
이 후 누군가 각 노드에 있는 부모계정에 접속해 하위계정을 만들었다고 치자.

현실세계로 가정하면 노드는 사람이고, 각 부모계정은 사람이 소유한 지갑.
여기에 특수한 상황을 부여하면, 하위계정들도 지갑들이라고 하지만
외부에서는 보이지 않음. 외부에서는 부모계정 지갑 하나만 보이고 알 수 있음.
일단은.

UTXO를 사용한다는 것은. 부모계정에 존재하는 하위계정들은 카드라고 치자
각 하위계정에도 돈이 들어 있을텐데 각 하위계정 별로 +-가 있을수 있음
하지만 한 부모계정에 묶인 전체계정의 총 합은 -여서는 안됨

utxo는 각각의 하위계정(카드)에 코드를 붙여 각 카드에서 돈을 보내게 되면

각 하위계정에서 돈을 보내고 각 하위계정이 가진 hash 값을
m1		n1
m2	->	n2
m3		n3
라고 하고 m2 -> n2 로 보낸다고 하면
보내고 나면  m2 가 n2로 가면서 값이 바뀌어서 들어가고
m2도 m2a 이런식으로 hash 값이 변경이 되고
새로운 보유량 값의 hash 값으로 저장이 된다

비트코인은 utxo 구조 이더리움은 account 구조 를 사용

geth나 기타등등 이용해서 block을 조회 할때

root가 붙은 애들이 있다. 러ㅐㅑㄷ저ㅐㅑㄹ머ㅐㅑㄷㅈroot
*root. *=뭐가 붙을수 있다는 뜻
*root: hash
*root 에서 *는 많은 data를 가지고 있다는 뜻이고

txs= 리스트로 저장이 되는데,
많은경우에 합쳐서 *로 root로 header에 저장.

1,2,3,4 가 있으면

1,2를 hashing 하고 3,4를 hashing 하고
1+2, 3+4를 hashing을 해서 이만 저장함.

이거랑 딴거를 만나면 두개를 hashing을 해서 맞냐 아니냐 확인해서
저장함. 아니면 다버린대.

트리구조는 자료구조의 일부
근데 앞에 뭐가 붙냐에 따라 다름

이게 머클트리고

패트리샤 트리가 있고.

하나는 0X1111111111	하나는 0x111111112 면
0x11111111 은 띄고 어디 저장하고 각 1,2, 만 하부로?

block tx state 다 합치면 800gb? 
페트리샤 트리는 저장소 때매 쓰고
머클트리는 검증 때매 쓰고

맨위에 있는애를 root 혹은 뿌리 라고 함. (내가봤을땐 top)


메인넷이ㅡ 선별기준
1. 거래소에 붙어있는 네트워크
2. 회사에서 주관하는 네트워크

에어드랍
거래소에서 많이 하는 이벤트


